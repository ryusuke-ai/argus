# Argus 面接対策ガイド — 隅々まで答えるための完全解説

このドキュメントは面接で Argus について聞かれたとき、**設計判断の理由、トレードオフ、失敗と学び、今後の改善点**まで含めて答えられるようにするためのものです。

---

## 1. 一言で説明する（エレベーターピッチ）

> 「Argus は、AI エージェントの運用を自動化するシステムです。Slack から指示を出すと Claude が自律的にタスクを実行し、その過程を全て記録・可視化します。12パッケージの pnpm monorepo で、1,192 のテストケースがあります。」

**30秒版:**

> 「個人で運用している AI エージェントシステムで、Slack Bot、管理ダッシュボード、スケジューラーの3つのアプリと9つの共有パッケージで構成されています。Claude Agent SDK を使ってエージェントを実行し、MCP サーバーで Gmail やカレンダーと連携します。monorepo 設計で型安全性を保ちながら、1,192 テストで品質を担保しています。」

---

## 2. なぜ作ったか（動機）

### 聞かれ方

- 「なぜこのプロジェクトを作ったんですか？」
- 「どんな課題を解決したかったんですか？」

### 答え方

**課題**: AI エージェント（Claude）を日常業務に使いたいが、毎回 CLI を手動で叩くのは非効率だった。特に以下の問題があった：

1. **実行の再現性がない** — 同じプロンプトでも結果が変わる。何がうまくいって何がダメだったかの記録がない
2. **ツール連携が手動** — Gmail を確認して、カレンダーに予定を入れて、Slack に報告して…という手動フローが多すぎる
3. **スケジュール実行ができない** — 毎朝のニュース収集や定期的なコード品質チェックを自動化したい
4. **観測できない** — エージェントが裏で何をやっているか見えない。どのツールをどのくらいの時間使ったか分からない

**解決策**: Slack をインターフェースにして、エージェントの実行・観測・記憶を一元管理するシステムを構築した。

---

## 3. アーキテクチャ（全体像）

### 聞かれ方

- 「アーキテクチャを説明してください」
- 「どういう構成になっていますか？」

### 答え方

```
ユーザー
  ↓ Slack メッセージ
slack-bot (Port 3939)
  ├── SessionManager: query() / resume() で Claude Agent SDK を実行
  ├── MCP サーバー: Gmail, Calendar, Knowledge を疎結合に統合
  ├── Hooks: 全ツール実行を DB に記録
  └── 結果を Slack スレッドに返信

agent-orchestrator (Port 3950)
  ├── Cron スケジューラー: 定期タスクの実行
  ├── Knowledge REST API: ナレッジベースの CRUD
  ├── Daily Planner: 毎朝のデイリープラン生成
  └── Code Patrol: 週次のコード品質チェック

dashboard (Port 3150)
  ├── セッション一覧・詳細表示
  ├── ナレッジベース管理
  ├── ファイルブラウザ（動画・音声配信）
  └── Quick Query（ダッシュボードから直接 Claude に質問）

共有パッケージ (9個)
  ├── agent-core: SDK ラッパー（query, resume, hooks）
  ├── db: Drizzle ORM + PostgreSQL スキーマ
  ├── gmail: Gmail MCP サーバー
  ├── google-calendar: Calendar MCP サーバー
  ├── knowledge: Knowledge MCP サーバー（権限分離）
  ├── knowledge-personal: パーソナルナレッジ MCP サーバー
  ├── r2-storage: Cloudflare R2 ストレージ
  ├── slack-canvas: Slack Canvas 管理
  └── tiktok: TikTok API 連携
```

### 深掘り用：なぜこの構成か

**Q: なぜ3つのアプリに分けたのか？**

A: 関心の分離。slack-bot は「ユーザーとの対話」、orchestrator は「自律的なスケジュール実行」、dashboard は「可視化」という異なる責務を持つ。1つのプロセスにまとめると、Slack Bot の障害がダッシュボードに影響するなど、障害の伝播が起きる。PM2 で個別にプロセス管理することで、1つが落ちても他は動き続ける。

**Q: なぜ monorepo なのか？**

A: 3つのアプリが共有する型定義（DB スキーマ、AgentResult 型等）を一元管理するため。別リポジトリだと、DB スキーマを変更するたびに複数リポジトリを同期する必要がある。pnpm workspace の workspace:\* プロトコルで常に最新のローカルパッケージを参照できる。

**Q: なぜ pnpm なのか？npm や yarn ではダメなのか？**

A: 3つの理由：

1. **ストレージ効率**: pnpm はハードリンクで node_modules を共有するので、monorepo でのディスク使用量が大幅に少ない
2. **厳密な依存解決**: phantom dependencies（明示的に依存宣言していないパッケージの使用）を防ぐ
3. **workspace プロトコル**: `workspace:*` で常にローカルのパッケージを参照でき、monorepo の開発体験が良い

---

## 4. 技術選定の理由

### 聞かれ方

- 「なぜこの技術を選んだんですか？」
- 「他の選択肢と比較しましたか？」

### Claude Agent SDK（最重要）

**選定理由**: 最初は Claude CLI をサブプロセスとして起動し、stdout をパースしていた（cli-runner.ts / stream-parser.ts）。しかし以下の限界があった：

- CLI の出力フォーマットが非公式で、バージョンアップで壊れる
- セッション管理が不安定（resume の挙動が一貫しない）
- hooks（ツール実行の前後処理）ができない

SDK（@anthropic-ai/claude-agent-sdk）に移行したことで：

- **型安全な AsyncGenerator**: `query()` が `AsyncGenerator<SDKMessage>` を返し、型で分岐処理できる
- **公式の hooks API**: `HookCallbackMatcher[]` でツール実行の前後に任意の処理を挿入
- **安定したセッション管理**: `resume()` でセッションを確実に継続

**トレードオフ**: SDK は独自バンドルの cli.js を使うため、ローカルの Claude CLI とは別。Max Plan（ローカル CLI 経由の無料利用）を使う場合の切り替えロジックが複雑になった。

### Drizzle ORM

**選定理由**: TypeScript ファースト。スキーマ定義が TypeScript で書け、クエリの戻り値が型安全。Prisma と比較して：

- **Prisma**: コード生成が必要（`prisma generate`）。ビルドステップが増える。クライアントの型が巨大
- **Drizzle**: コード生成不要。スキーマ定義がそのまま型になる。軽量（バンドルサイズが小さい）

**トレードオフ**: Prisma ほどのエコシステムやドキュメントの充実度はない。複雑な relation のクエリはやや書きにくい。

### MCP（Model Context Protocol）

**選定理由**: エージェントのツール拡張を疎結合にしたかった。MCP なしだと、Gmail 連携のコードが agent-core に直接組み込まれ、依存が密結合になる。MCP サーバーとして分離することで：

- **独立してテスト可能**: Gmail MCP サーバー単体でテストできる
- **動的なツール追加**: Playwright MCP はキーワード検出時のみ追加（約 7,000 トークン節約）
- **権限分離**: Knowledge MCP は Collector（書き込み可）と Executor（読み取りのみ）で権限を分ける

**トレードオフ**: MCP サーバーは child process として起動されるため、起動時のオーバーヘッドがある。また、MCP プロトコル自体がまだ発展途上で、仕様変更のリスクがある。

### Next.js 16 + React 19（Dashboard）

**選定理由**: App Router でサーバーコンポーネントが使え、DB から直接データを取得してレンダリングできる。API ルートでファイル配信（MP4/MP3）もできるので、別途ファイルサーバーを立てる必要がない。

### Supabase + PostgreSQL

**選定理由**: Firebase から移行した。Firebase は NoSQL（Firestore）で、リレーショナルなデータ（sessions → messages → tasks の関係）を扱うのが不自然だった。PostgreSQL + Drizzle ORM にすることで、型安全な SQL クエリが書ける。Supabase はマネージド PostgreSQL として最も手軽。

---

## 5. 設計パターンの解説

### セッション管理

**「1 Slack Thread = 1 Session」の原則**

- 新しいスレッドでメッセージが来たら `query()` で新セッション開始
- 既存スレッドなら `resume()` でセッション継続（文脈を保持）
- resume が失敗したら query にフォールバック（SDK のセッションが期限切れの場合）
- user/assistant 両方のメッセージを DB に保存し、後から再構成可能

**なぜこの設計か**: Slack のスレッドがユーザーにとって自然な「会話の単位」だから。別々のスレッドは別々の文脈として扱うのが直感的。

### Hooks（観測パターン）

**最も重要な設計判断の一つ。**

- `PreToolUse`: ツール実行前に開始時刻を記録 + Slack に「〜を実行中...」と通知
- `PostToolUse`: ツール実行後に結果・所要時間・ステータスを DB に保存
- `onToolFailure`: ツール失敗時にエラーを lessons テーブルに記録（エピソード記憶）

**なぜ観測が重要か**: エージェントは「ブラックボックス」になりがち。何が起きたか後から分かるようにしないと、問題の原因特定ができない。tasks テーブルに全ツール実行を記録することで、「あの処理で何分かかったか」「どのツールが失敗したか」を定量的に把握できる。

### 権限分離（Collector/Executor）

- **Collector エージェント**: Knowledge の add/update/archive/search/list（書き込み権限あり）
- **Executor エージェント**: Knowledge の search のみ（読み取り専用）

**なぜ**: エージェントに全権限を与えると、誤って重要なナレッジを上書きしたり削除したりするリスクがある。最小権限の原則で「壊れにくさ」を作る。

### DB クライアントの遅延初期化

`Proxy` を使い、最初の DB アクセス時にのみ接続を確立する。

**なぜ**: Next.js のビルド時に `import { db } from "@argus/db"` が評価されるが、ビルド時には DATABASE_URL がない。遅延初期化にすることで、ビルドは通るが実際の接続はランタイムまで遅延される。Dockerfile でダミー DATABASE_URL を使うハックも不要になる。

### Max Plan 自動切り替え

- macOS + `~/.local/bin/claude` が存在 → Max Plan（ローカル Claude Desktop 経由、API キー不要）
- Linux（サーバー）→ API キー使用

**なぜ**: ローカル開発時は Max Plan（月額制の Claude Desktop に含まれる）を使えば API コストがゼロ。サーバーでは Claude Desktop がないので API キーが必要。この切り替えを自動化した。

**注意点**: `which claude` コマンドは子プロセスの PATH 依存で失敗するケースがあったため、`fs.existsSync()` で直接ファイルの存在をチェックする方式に変更した。

---

## 6. テスト戦略

### 聞かれ方

- 「テストはどうやって書いていますか？」
- 「1,192 テストケースって多いですが、どういう方針ですか？」

### 答え方

**方針**: 全てのモジュールにコロケーションテスト（`foo.ts` の隣に `foo.test.ts`）を置く。

**テストの種類**:

- **Unit テスト（99%）**: `vi.mock()` で依存をモックし、関数単位でテスト
- **Integration テスト（1ファイル）**: orchestrator の統合テスト
- **テスト環境**: Vitest 4、dashboard は jsdom + Testing Library

**テスト対象の優先順位**:

1. **ビジネスロジック**: メッセージ分類、タスク実行判定、進捗通知フォーマット
2. **データ変換**: SDK メッセージの AgentResult への変換、mrkdwn フォーマット
3. **エラーハンドリング**: フォールバック、タイムアウト、不正入力

**SDK のテスト方法**: `fakeStream()` ヘルパーで `AsyncGenerator<SDKMessage>` をモック。実際の Claude API を呼ばずに、SDK の応答パターン（init → assistant → result）をシミュレート。

**なぜこの量か**: エージェントの挙動は非決定的（同じ入力でも異なる出力）だが、その周辺のコード（入力のパース、出力のフォーマット、DB への保存）は決定的。決定的な部分を徹底的にテストすることで、非決定的なエージェントの出力に対しても「周辺が壊れていない」という安心感を持てる。

---

## 7. 失敗と学び

### 聞かれ方

- 「開発で苦労したことは？」
- 「失敗から学んだことは？」

### 答え方（3つ用意）

#### 失敗1: CLI ラッパーの限界

**何が起きたか**: 最初は Claude CLI をサブプロセスとして起動し、stdout をパースしていた。しかし CLI のバージョンアップで出力フォーマットが変わり、パーサーが壊れた。

**学び**: 非公式なインターフェースに依存すると、上流の変更で壊れる。公式 SDK に移行したことで、型安全かつ安定した統合ができるようになった。レガシーコード（cli-runner.ts, stream-parser.ts）は参考用に残しているが、もう使っていない。

#### 失敗2: Slack Socket Mode の複数インスタンス問題

**何が起きたか**: slack-bot を再起動する際、古いプロセスを kill せずに新しいプロセスを起動してしまった。Slack Socket Mode は接続中の全インスタンスにメッセージをラウンドロビン配信するため、メッセージが古いコードで処理されて間欠的に失敗した。

**学び**: プロセス管理は「起動」だけでなく「停止」も重要。PM2 を導入し、`pm2 restart` で確実にプロセスを入れ替えるようにした。

#### 失敗3: lessons テーブルの stale データ

**何が起きたか**: lessons テーブル（エピソード記憶）に「Gmail トークンが見つからない」というレッスンが残っていた。その後トークンを設定したのに、エージェントがレッスンを参照して「Gmail は使えない」と判断し、Gmail ツールをスキップし続けた。

**学び**: エピソード記憶は「状況が変わったら更新・削除する」仕組みが必要。lessons の自動クリーンアップスクリプトを導入し、古いレッスンを定期削除するようにした。

---

## 8. 今後の改善点

### 聞かれ方

- 「今後改善したい点は？」
- 「もし作り直すとしたら何を変えますか？」

### 答え方

1. **E2E テストの追加**: 現在は Unit テストが中心。Slack Bot の end-to-end フロー（メッセージ送信 → SDK 実行 → DB 保存 → Slack 返信）をテストするフレームワークを構築したい

2. **コスト最適化**: 現在は全てのリクエストで Opus を使っているが、簡単な質問には Haiku で十分。リクエストの複雑さに応じてモデルを自動選択する仕組みを入れたい

3. **マルチテナント化**: 現在は自分専用だが、チームで使えるようにするには認証・認可の仕組みが必要。Dashboard に認証を追加し、ユーザーごとにセッションを分離する

4. **エラーリカバリの強化**: SDK のセッションが切れた場合のリカバリがフォールバック方式（resume 失敗 → 新規 query）だが、メッセージ履歴を引き継ぐ仕組みがない

5. **メトリクス・ダッシュボード**: tasks テーブルのデータを集計して、ツール使用頻度・平均実行時間・エラー率を可視化したい

---

## 9. 数字で語る

面接では「数字」が説得力を持つ。以下を暗記しておく：

| 指標                      | 数値                                                |
| ------------------------- | --------------------------------------------------- |
| パッケージ数              | 12（3 apps + 9 packages）                           |
| テストケース数            | 1,192                                               |
| テストファイル数          | 91                                                  |
| TypeScript 行数           | 約 54,500行                                         |
| DB テーブル数             | 17                                                  |
| MCP サーバー数            | 4（Gmail, Calendar, Knowledge, Knowledge-Personal） |
| 対応 SNS プラットフォーム | 10                                                  |
| スキル定義数              | 32                                                  |
| ADR（設計判断記録）数     | 5                                                   |
| 設計文書数                | 17                                                  |
| 開発期間                  | 約3ヶ月（2025年12月〜）                             |
| デプロイ環境              | Railway VPS + Cloudflare Tunnel + Access            |

---

## 10. よくある面接質問 Q&A

### Q: このプロジェクトで一番難しかったことは？

A: 「Claude Agent SDK への移行判断と実行」です。既に CLI ラッパーで動いていたので「動いているものを変える」リスクがあった。しかし CLI の出力パーサーが壊れやすく、hooks も使えなかった。SDK の AsyncGenerator API を理解し、既存の公開 API（AgentResult 型）を変えずに内部実装だけ差し替える設計にしたことで、消費側（slack-bot, orchestrator, dashboard）のコードを一切変更せずに移行できました。

### Q: チーム開発を意識した設計はありますか？

A: はい、3つあります：

1. **monorepo + 型安全**: パッケージ間の依存を TypeScript の型で保証。DB スキーマの変更が消費側で即座にコンパイルエラーになる
2. **権限分離**: Collector/Executor パターンで最小権限を実現。新しいエージェントを追加する人が Knowledge を壊すリスクを減らす
3. **ADR**: 5つの Architecture Decision Records で設計判断の経緯を文書化。後から join する人が「なぜこうなっているか」を理解できる

### Q: セキュリティはどう考えていますか？

A: 3つのレイヤーで対策しています：

1. **アプリケーション**: `.claude/settings.json` で deny-first の権限設定。`.env`、`rm -rf`、`DROP TABLE` 等の危険な操作を拒否
2. **インフラ**: Cloudflare Access でメール認証。Dashboard は認証なしではアクセスできない
3. **データ**: API キーやトークンは環境変数で管理し、コードにハードコードしない。DB のトークンカラムも環境変数経由

### Q: パフォーマンスの工夫は？

A: 3つあります：

1. **Playwright MCP の動的追加**: ブラウザ操作が必要なキーワードが検出された時のみ Playwright MCP サーバーを起動。常時起動だと約 7,000 トークンのツール定義が常に送信されるが、動的追加で不要時のコストを削減
2. **進捗通知のスロットル**: Slack への進捗メッセージを 5秒/8秒 スロットルで送信。ツールが高速に連続実行される場合のメッセージ氾濫を防止
3. **DB クライアントの遅延初期化**: Proxy パターンで初回アクセス時のみ接続。ビルド時やテスト時の不要な接続を回避

### Q: AI でコード書いてるだけじゃないの？

A: Claude Code を活用して開発していますが、**設計判断は全て自分で行っています**。例えば：

- CLI → SDK 移行の判断は、CLI パーサーが壊れた経験から自分で決断した
- MCP による疎結合設計は、直接統合で依存が絡まった経験からの学び
- 権限分離（Collector/Executor）は、エージェントがナレッジを誤って上書きした事故から設計した

AI はコードの実装を高速化するツールであり、**何を作るか・なぜそう設計するかは人間が決める**。CLAUDE.md や skills/ の設計パターンは「AI に何をさせるか」のコンテキストエンジニアリングであり、これ自体がスキル。

### Q: なぜ個人開発なのにこんなに規模が大きいのか？

A: Claude Code を使って開発しているからです。ただし「AI に全部書かせた」のではなく、**AI の生産性を最大化する仕組み自体を設計した**のがポイントです：

- `CLAUDE.md` にプロジェクトの全体像とコーディング規約を集約 → AI が一貫したコードを生成
- `.claude/rules/` でアーキテクチャルールを文書化 → AI が設計パターンを踏襲
- `.claude/skills/` でタスクのテンプレートを定義 → 繰り返しタスクの品質が安定
- hooks で段階的開示 → AI のコンテキストウィンドウを効率的に使用

これは「AI 駆動開発のワークフロー設計」であり、単にコードを書く以上のスキル。

### Q: Firebase から Supabase に移行した理由は？

A: 3つの理由：

1. **データモデルの不一致**: Firestore は NoSQL で、sessions → messages → tasks のリレーショナルな構造を扱うのが不自然。join ができないのでクライアント側で結合する必要があった
2. **型安全性**: Drizzle ORM + PostgreSQL なら、スキーマ定義がそのまま TypeScript の型になる。Firestore のドキュメント型は手動で定義が必要
3. **SQL の表現力**: 集計クエリ（ツール使用頻度、平均実行時間）が SQL なら簡潔に書ける

---

## 11. 企業別のアピールポイント

### ラッコ向け

- **AI 活用**: Claude Agent SDK 統合、CLAUDE.md によるコンテキストエンジニアリング → 「AI を前向きに受け入れ、自ら学び、チームに展開できる」
- **AWS**: （サブプロジェクトで補強後）Lambda + API Gateway + DynamoDB の実装経験
- **フルリモート**: テキストベースのコミュニケーション文化（ADR、設計文書17本）

### アシアル向け

- **技術スタック一致**: TypeScript, React, Node.js, Next.js, Jest (Vitest)
- **AI 活用**: GitHub Copilot, ChatGPT を活用する文化に Argus の AI 駆動開発が刺さる
- **グローバル志向**: 英語ドキュメントの読み書き、OSS ツールの活用

### SO Technologies / Helpfeel 向け

- **React/Node.js の実務力**: Dashboard (React 19) + Orchestrator (Express 5)
- **テスト文化**: 1,192 テストケース、コロケーション方式

### テックタッチ向け

- **AI Agent 経験**: Claude Agent SDK、MCP、hooks、セッション管理 → AI Agent 事業の立ち上げに直接活かせる
- **設計力**: 権限分離、エピソード記憶、コンテキストエンジニアリング

### note 向け

- **AI 活用が日常**: CLAUDE.md、skills、hooks の設計 → 「AI コーディングエディタを日常的に活用」
- **個人 Web サービス開発**: Argus 自体が「個人で運用している Web サービス」

### GitLab / Sales Marker 向け

- **TypeScript + AI**: GitLab Duo のエディタ拡張、Sales Marker の Next.js フロントエンド
- **非同期コミュニケーション**: ADR、設計文書、テキストベースの意思決定

---

## 12. 自己紹介テンプレート（2分）

> 九州工業大学情報工学科を2025年3月に卒業し、約1年の実務経験があります。
>
> 技術スタックは TypeScript、React、Next.js、Node.js が中心で、個人開発として「Argus」という AI エージェント運用システムを作っています。
>
> Argus は Slack から指示を出すと Claude が自律的にタスクを実行するシステムで、12パッケージの pnpm monorepo、1,192 のテストケース、4つの MCP サーバーで構成されています。
>
> 特に力を入れたのは、Claude Agent SDK の統合と MCP によるツール拡張の疎結合設計です。最初は CLI ラッパーで実装していましたが、安定性の問題から SDK に移行する判断をし、公開 API を変えずに内部実装を差し替えました。
>
> AI を「使う」だけでなく、「AI の生産性を最大化するワークフロー」を設計することに興味があり、CLAUDE.md やスキル定義によるコンテキストエンジニアリングも実践しています。
>
> 御社の[事業/技術]に、この経験を活かして貢献したいと考えています。

---

_作成日: 2026年2月14日_
